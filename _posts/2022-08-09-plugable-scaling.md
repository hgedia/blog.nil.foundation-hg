---
title: <span style='font-family:Menlo, Courier, monospace'>=nil;</span>'s Pluggable Scaling.
layout: post
date: 2022-08-09
excerpt: What is Pluggable scaling?
author: Haresh G.
tags: dbms io
comments: false
---
# Introduction
Monolithic blockchains have suffered throughput bottleneck in terms of transactions/sec during peak utilization. 
This inability to meet demand results in higher transaction costs and wait times for users. 
Solution to address this have resulted in newer chains adopting different architectures such as 
subnets (Avalance) , supernets (Polygon) or hub-spoke architectures such as Cosmos IBC, Polkadot etc. 

Another branch of these solutions have taken form of Optimistic/zk-rollups which inherit security 
from the base layer they are built on.The rollup centric solution is part of the ETH2 upgrade, 
which eventually plans to move to sharding to provide data availability to the rollups, with
the possibility of having data shards execute smart contracts in the future. Application specific 
chains are proposed to be built on top of rollups moving another degree away from the base layer.

Both approaches above silo the application on to a single network.

In this post we propose an alternative scaling mechanism via =nil;Foundations solution stack comprising
DBMS like nodes which help scale a base layer via state and query proofs by running a number of clusters
in parallel to load balance the transaction load.


# Concepts

Following concepts will aid us in understanding the proposed solution.

**State/Query Proofs** : These are validity proofs generated by =nil;DBMS nodes which prove the state
and a response to the query. Some networks inherently generate these (MINA/CELO) ; whilst 
these are implemented on a network basis by writing protocol and I/O adapters. Generation of the proof
have a cost associated with it (hardware/electricity) whilst for most use case, verification costs
are to be expressed as transaction costs as the verifiers are deployed in smart contracts.

**Placeholder proof** :
Placeholder is =nil's in-house proof system for which all proofs are generated. Once a
proof system is implemented for a network, this allows a network to perform its local
consistency checks before committing/implementing associated logic.

# Clustering

When users notice a slowdown in response times (or higher costs) in DBMS , it is first identified 
what subset of the data is causing the spike and based on severity, it can be moved to its own partition or
database. Similarly, when we see spikes in usage of a subset of data in blockchain networks, 
the approach should be to move this to a different partition/db (network). 
This implies your application data is stored and accessed across two or more partitions.


# Single cluster Model

This model simulates the transaction flows, transaction price & gas consumed by a transaction and measures the outputs of 
transaction time ,cost and price for current ethereum network; which can be viewed as a single cluster model.

Transaction flow : This model estimates, how many transactions are being queued on the network every 15 seconds interval

1. Number of transactions = A Poisson distribution is used to map how many transactions enter the network based on a number of assumptions.
   We adjust this distribution with a flow rate & elasticity constant, implying if the rate is high , the number of 
   new transactions  will reduce.
2. Transaction Price = This is modeled based on current ETH gas price computation having components of base fee and priority fee.
   Priority fees again are assumed to have a log-normal distribution to choose between (slow-normal-fast) speeds.
3. Gas used per transaction = This is average gas consumed by transactions on the network.

This snapshot is created every 15 seconds simulating the mempool.

Block generation : Simulating creation of blocks adhering to current protocol rules on ethereum.

1. Selecting transactions with best price. 
2. Ensuring selected transactions do not violate the block limits.
3. Removing these transactions from the mempool
4. Re-calculating the gas price base fee for next iteration.

Transaction flow & Block generation is simulated at every 15 seconds.

# Multi cluster Model

We now adapt the above model to simulate the same metrics of transaction flow , queue  time & cost , but having more than one ETH 
ETH cluster running.

Transaction flow : This model estimates, how many transactions are being queued on the network every 15 seconds interval in 
a multi-cluster configuration. The assumed number of eth clusters is TODO : confirm then number 10 sub clusters & one main cluster.
Below we discuss the adjustments to the parameters outlined above.

TODO : Check how load is distributed between main & sub-clusters

1. Number of transactions = rate adjustments for additional clusters.
2. Transaction Price = price adjustments to take into account transaction has a proof generation 
   & verification cost associated with it.  (Check how is this created? i.e sc1 proof verified in mc?)
3. Gas used per transaction = adjustments for additional clusters.

This snapshot is created every 15 seconds simulating the mempool for each of the clusters involved.

Block generation : Simulating creation of blocks adhering to current protocol rules on ethereum local to each sub-cluster.

1. Selecting transactions with best price.
2. Ensuring selected transactions do not violate the block limits.
3. Removing these transactions from the mempool
4. Re-calculating the gas price base fee for next iteration.

Transaction flow & Block generation is simulated at every 15 seconds.

# Findings

## Gas Price

## Transaction Fees

## 
