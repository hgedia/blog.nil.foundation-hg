---
title: <span style='font-family:Menlo, Courier, monospace'>=nil;</span>'s Pluggable Scaling.
layout: post
date: 2022-08-09
excerpt: What is Pluggable scaling?
author: Haresh G.
tags: dbms io
comments: false
---
# Introduction
Monolithic blockchains have suffered throughput bottleneck in terms of transactions/sec during peak utilization. 
This inability to meet demand results in higher transaction costs and wait times for users. 
Solution to address this have resulted in newer chains adopting different architectures such as 
subnets (Avalance) , supernets (Polygon) or hub-spoke architectures such as Cosmos IBC & Polkadot. 

Another branch of these solutions have taken form of Optimistic/zk-rollups which inherit security 
from the base layer they are built on.The rollup centric solution is part of the ETH2 upgrade, 
which eventually plans to move to sharding to provide data availability to the rollups, with
the possibility of having data shards execute smart contracts in the future. Application specific 
chains are proposed to be built on top of rollups moving another degree away from the base layer.

Both approaches above silo the application on to a single network.

In this post we propose an alternative scaling mechanism comprising =nil;Foundation DBMS nodes 
which help scale a base layer using validity proofs for state and query by running a number of clusters 
in parallel to load balance the transaction load.


# Concepts

Following concepts will aid us in understanding the proposed solution.

**State/Query proofs** : These are validity proofs generated by =nil;DBMS nodes which prove the state
and a response to the query. Some networks inherently generate these (MINA/CELO) ; whilst those which do not
(ETH/SOLANA) these are implemented on a network basis by writing protocol and I/O adapters. Generation of the proof
has a cost associated with it (hardware/electricity) whilst for most use cases, verification costs
are to be expressed as transaction costs as the verifiers are deployed in smart contracts.

**Placeholder proof system** :
Placeholder is =nil's in-house proof system for which all proofs are generated. Once a
proof system is implemented for a network, this allows a network to perform its local
consistency checks before committing/implementing associated logic.

# Clustering
When users notice a slowdown in response times (or higher costs) in DBMS , it is first identified 
what subset of the data is causing the spike and based on severity, it can be moved to its own partition or
database. Similarly, when we see spikes in usage of a subset of data in blockchain networks, 
the proposed approach is to move this to a different partition/db (network). 

This implies, your application data can reside in more than one db or can be wholly moved to a
different db cluster to ease the network.


# Model 

We define and compare two models and the parameters which govern them. Ethereum main-net is taken as a base for calculations,
this can with a change of parameters can be extrapolated to any other network.
- Single Cluster:  This behaves as the current ethereum mainnet.
- Multiple Clusters: We take 10 ethereum alike clusters which run alongside a main ethereum cluster.They are their
  own networks, these could be app chains.
  
The model simulates the transaction flows, transaction price & average gas consumed by a transaction. 
It measures the outputs of transaction time,cost and price for current ethereum network

# Single cluster


Transaction flow : This model estimates, how many transactions are being queued on the network every 15 seconds interval

1. Number of transactions = A Poisson distribution is used to map how many transactions enter the network based on a number of assumptions.
   We adjust this distribution with a flow rate & elasticity constant, implying if the rate is high , the number of 
   new transactions  will reduce.
2. Transaction Price = This is modeled based on current ETH gas price computation having components of base fee and priority fee.
   Priority fees again are assumed to have a log-normal distribution to choose between (slow-normal-fast) speeds.
3. Gas used per transaction = This is average gas consumed by transactions on the network.

This snapshot is created every 15 seconds simulating the mempool.

Block generation : Simulating creation of blocks adhering to current protocol rules on ethereum.

1. Selecting transactions with best price. 
2. Ensuring selected transactions do not violate the block limits.
3. Removing these transactions from the mempool
4. Re-calculating the gas price base fee for next iteration.

Transaction flow & Block generation is simulated at every 15 seconds.

# Multi cluster

We now adapt the above model to simulate the same metrics of transaction flow , queue  time & cost , but having more than one ETH 
ETH cluster running.

Transaction flow : This model estimates, how many transactions are being queued on the network every 15 seconds interval in 
a multi-cluster configuration. The assumed number of eth clusters is TODO : confirm then number 10 sub clusters & one main cluster.
Below we discuss the adjustments to the parameters outlined above.

TODO : Check how load is distributed between main & sub-clusters

1. Number of transactions = rate adjustments for additional clusters.
2. Transaction Price = price adjustments to take into account transaction has a proof generation 
   & verification cost associated with it.  (Check how is this created? i.e sc1 proof verified in mc?)
3. Gas used per transaction = adjustments for additional clusters.

This snapshot is created every 15 seconds simulating the mempool for each of the clusters involved.

Block generation : Simulating creation of blocks adhering to current protocol rules on ethereum local to each sub-cluster.

1. Selecting transactions with best price.
2. Ensuring selected transactions do not violate the block limits.
3. Removing these transactions from the mempool
4. Re-calculating the gas price base fee for next iteration.

Transaction flow & Block generation is simulated at every 15 seconds.

# Findings

## Gas Price

## Transaction Fees

## Average wait time in mempool

## Mempool Backlog 

# Conclusion