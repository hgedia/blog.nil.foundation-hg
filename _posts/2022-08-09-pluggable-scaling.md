---
title: <span style='font-family:Menlo, Courier, monospace'>=nil;</span>'s Pluggable Scaling.
layout: post
date: 2022-08-09
excerpt: What is Pluggable scaling?
author: Haresh G.
tags: dbms io
comments: false
---
# Introduction
Monolithic blockchains have suffered throughput bottleneck in terms of transactions/sec during peak utilization. 
This inability to meet demand results in higher transaction costs and wait times for users. 
Solution to address this have resulted in newer chains adopting different architectures such as 
subnets (Avalance) , supernets (Polygon) or hub-spoke architectures such as Cosmos IBC & Polkadot. 

Another branch of these solutions have taken form of Optimistic/zk-rollups which inherit security 
from the base layer they are built on.The rollup centric solution is part of the ETH2 upgrade, 
which eventually plans to move to sharding to provide data availability to the rollups, with
the possibility of having data shards execute smart contracts in the future. Application specific 
chains are proposed to be built on top of rollups moving another degree away from the base layer.

Both approaches above silo the application on to a single network.

In this post we propose an alternative scaling mechanism comprising =nil;Foundation DBMS nodes 
which help scale a base layer using validity proofs for state and query by running a number of clusters 
in parallel to load balance the transaction load.


# Concepts

Following concepts will aid us in understanding the proposed solution.

**State/Query proofs** : These are validity proofs generated by =nil;DBMS nodes which prove the state
and a response to the query. Some networks inherently generate these (MINA/CELO) ; whilst those which do not
(ETH/SOLANA) these are implemented on a network basis by writing protocol and I/O adapters. Generation of the proof
has a cost associated with it (hardware/electricity) whilst for most use cases, verification costs
are to be expressed as transaction costs as the verifiers are deployed in smart contracts.

**Placeholder proof system** :
Placeholder is =nil's in-house proof system for which all proofs are generated. Once a
proof system is implemented for a network, this allows a network to perform its local
consistency checks before committing/implementing associated logic.

# Clustering
When users notice a slowdown in response times (or higher costs) in DBMS , it is first identified 
what subset of the data is causing the spike and based on severity, it can be moved to its own partition or
database. Similarly, when we see spikes in usage of a subset of data in blockchain networks, 
the proposed approach is to move this to a different partition/db (network). 

This implies, your application data can reside in more than one db or can be wholly moved to a
different db cluster to ease the network.


# Model 

We define and compare two models and the parameters which govern them. Ethereum main-net is taken as a base for calculations,
this can with a change of parameters can be extrapolated to any other network.
- Single Cluster:  This behaves as the current ethereum main-net.
- Multiple Clusters: We take 10 ethereum alike clusters which run alongside a main ethereum cluster.They are their
  own networks, these could be app chains.
  
The model simulates the transaction flows, transaction price & average gas consumed by a transaction. 
It measures the outputs of transaction time,cost and price for current ethereum network.

# Single cluster

![](assets/images/2022-08-09-pluggable-scaling/single_cluster.png)

Transaction flow : Estimates of how many transactions are being queued on the network every 15 seconds interval.

1. *Number of transactions* : A Poisson distribution is used to map how many transactions enter the network based on a number of assumptions.
   We adjust this distribution with a flow rate & elasticity constant, implying if the rate is high , the number of 
   new transactions added to the network will reduce.
//TODO  : Verify these formulas
2. *Transaction Price* :  This is modeled based on current ETH gas price computation having components of base fee and priority fee.
   Priority fees again are assumed to have a log-normal distribution to choose between (slow-normal-fast) speeds.
3. *Gas used per transaction* : This is average gas consumed by transactions on the network.

This snapshot is created every 15 seconds simulating the mempool.

Block generation : Simulating creation of blocks adhering to current protocol rules on ethereum.

1. Selecting transactions with best price. 
2. Ensuring selected transactions do not violate the block limits.
3. Removing selected transactions from the mem-pool.
4. Re-calculating the base fee for next iteration.

Transaction flow & Block generation is simulated at every 15 seconds.

# Multi cluster

![](assets/images/2022-08-09-pluggable-scaling/multi_cluster.png)

We modify the above parameters to simulate the same metrics of but instead of one , we have multiple  
ETH sub-cluster's running.

Transaction flow : Estimates of how many transactions are being queued on the network every 15 seconds interval in 
multi-cluster configuration.

Below we discuss the adjustments to the parameters outlined above.

//TODO  : Verify these formulas
1. Number of transactions = rate adjustments for additional clusters.
2. Transaction Price = price adjustments to take into account transaction price. This now has a proof generation 
   & verification cost associated with it , computer per block. (TODO VERIFY)
3. Gas used per transaction = adjustments for additional clusters.

This snapshot is created every 15 seconds simulating the mempool for each of the clusters involved.

Block generation : Simulating creation of blocks adhering to current protocol rules on ethereum local to each sub-cluster.

1. Selecting transactions with best price.
2. Ensuring selected transactions do not violate the block limits.
3. Removing selected transactions from the mem-pool.
4. Re-calculating the base fee for next iteration.

Transaction flow & Block generation is simulated at every 15 seconds.

## Assumptions
The following is a subset of variables/boundaries are assumed for the simulation. For the full list please see the code
```
Base hourly flowRate l0 :=  Daily Transactions/24 = ~55,000
Number of sub clusters := 10 (excluding 1 main cluster)
Main cluster load := 0.5 (50% , rest of the transactions are simulated on subclusters)
Gas consumed in average tx  := 80000
CPU hours to generate proof  := 8.4
Proof verification in gas for placeholer proof := 2,000,000
```

# Findings

## Gas Price
![](assets/images/2022-08-09-pluggable-scaling/gas_price.png)
Gas price in single cluster configuration is higher and more volatile as the transaction flow registers more load.
In multi cluster setup, we observe gas price is stable and low as expected as the load is shared amongst 11 clusters.

## Average transaction Fees
![](assets/images/2022-08-09-pluggable-scaling/avg_tx_price.png)
Average price in single cluster setup is volatile with the gas price & load. In multi cluster configuration , 
we notice more stable transaction costs. A fair observation is also the cost of transaction is higher when 
low number of transactions are on the network as this cost is associated to proof generation/verification.
On average, the cost is much lower in multi cluster setup.

## Average wait time 
![](assets/images/2022-08-09-pluggable-scaling/avg_tx_price.png)
Average waiting time for a transaction to be cleared from mempool has more spikes under loads where 
transactions can be waiting to be confirmed from few seconds (high gas price) to 20 minutes. Multi cluster
configuration clears the mempools much quicker and there is no wait lag experienced by the user.

## Transactions stuck in mempool 
![](assets/images/2022-08-09-pluggable-scaling/tx_stuck_mempool.png)
Any transaction which is in the mempool for over 1 hour is considered stuck for this conclusion. High variance
is observed in a single cluster configuration, while multi cluster configuration show no signs of backlog. 

# Conclusion

